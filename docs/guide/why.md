# ເປັນຫຍັງຕ້ອງເປັນ Vite

## ບັນຫາ

ກ່ອນທີ ES modules ຈະສາມາດໃຊ້ງານໄດ້ໃນບາວເຊີ, ເດີມນັກພັດທະນາບໍ່ມີກົນໄກໃນການຂຽນ JavaScript ໃນຮູບແບບ modular. ນີ້ແມ່ນເຫດຜົນທີພວກເຮົາທຸກຄົນຄຸ້ນເຄີຍກັບແນວຄິດຂອງ "bundling": ການໃຊ້ເຄື່ອງມືທີ່ຮວບຮ່ວມຂໍ້ມູນ, ປະມວນຜົນ ແລະ ເຊື່ອມ source module ຂອງເຮົາເຂົ້າກັນກັບຟາຍທີສາມາດແລ່ນໄດ້ໃນບາວເຊີ.

ເມື່ອເວລາຜ່ານໄປ ພວກເຮົາກໍໄດ້ເຫັນເຄື່ອງມືຢ່າງ [webpack](https://webpack.js.org/), [rollup](https://rollupjs.org) ແລະ [parcel](https://parceljs.org/), ທີປັບປຸງປະສົບການພັດທະນາສຳລັບນັກພັດທະນາ frontend ເປັນຢ່າງຫຼາຍ.

ເຖິງຢ່າງໃດກໍຕາມ, ເມື່ອພວກເຮົາສ້າງແອັບພິເຄຊັ່ນທີມີຄວາມໃຫຍ່ຂຶ້ນເລື້ອຍໆ, ປະລິມານຂອງ JavaScript ທີເຮົາກຳລັງຈັດການຢູ່ກໍເພີ່ມຂຶ້ນຢ່າງຫຼວງຫຼາຍເຊັ່ນກັນ. ມັນບໍ່ແມ່ນເລື່ອງແປກທີໂປເຈັກຂະໜາດໃຫຍ່ຈະມີຫຼາຍໂມດູ. ພວກເຮົາກຳລັງພົບບັນຫາຄໍຂວດດ້ານປະສິດທິພາບສຳລັບເຄື່ອງມືທີ່ໃຊ້ JavaScript: ມັນຈະໃຊ້ເວລາລໍຖ້າເກີນສົມຄວນ (ບາງເທື່ອກໍອາດຮອດນາທີ!) ທີ່ຈະແລ່ນ dev server ໄດ້, ແລະ ເຖິງວ່າຈະໃຊ້ Hot Module ແທນ (HMR), ການແກ້ໄຂຟາຍກໍອາດຈະໃຊ້ເວລາບໍ່ເທົ່າໃດວິນາທີຈຶ່ງຈະສະແດງເທິງບາວເຊີ. ການຕອບສະໜອງທີຊ້າອາດຈະສົ່ງຜົນກະທົບຕໍ່ປະສິດທິພາບ ແລະ ຄວາມສຸກຂອງນັກພັດທະນາເປັນຢ່າງຫຼາຍ.

Vite ຕັ້ງເປົ້າໝາຍທີ່ຈະແກ້ໄຂບັນຫາເຫຼົ່ານີ້ ໂດຍໃຊ້ປະໂຫຍດຈາກຄວາມກ້າວໜ້າໃໝ່ໆໃນລະບົບນິເວດເຊັ່ນ: ຄວາມພ້ອມໃນການໃຊ້ງານ ES module ໃນບາວເຊີ, ແລະ ການເພີ່ມຂຶ້ນຂອງເຄື່ອງມື JavaScript ທີ່ຂຽນໃນພາສາ compile-to-native.

### ເລີ່ມແລ່ນ Server ຊ້າ 

ເມືອແລ່ນ dev server ຄັ້ງທຳອິດ, ການຕັ້ງຄ່າ build ຕາມແບບ bundler-based ແມ່ນຈະຕ້ອງລວມຂໍ້ມູນຢ່າງຈິງຈັງ ແລະ ສ້າງແອັບພິເຄຊັ່ນທັງໝົດຂອງທ່ານກ່ອນທີມັນຈະສາມາດໃຫ້ບໍລິການ.

Vite ປັບປຸງເວລາການແລ່ນ dev server ຄັ້ງທຳອິດ ໂດຍການແບ່ງ module ໃນແອັບພິເຄຊັ່ນອອກເປັນ 2 ປະເພດ: **dependencies** ແລະ **source code**.

- **Dependencies** ສ່ວນຫຼາຍແມ່ນ JavaScript ທຳມະດາທີ່ບໍ່ມີການປ່ຽນແປງເລື້ອຍໆໃນລະຫວ່າງການພັດທະນາ. ບາງ dependency ທີໃຫຍ່ (ເຊັ່ນ: component libraries ທີ່ມາພ້ອມກັບຫຼາຍຮ້ອຍ module) ທີຄ່ອນຂ້າງໃຊ້ເວລາໃນການ process. Dependency ອາດຈະມາໃນຮູບແບບຂອງ module ຕ່າງໆ (ເຊັ່ນ: ESM ຫຼື CommonJS).

  Vite [pre-bundles dependencies](./dep-pre-bundling) ໃຊ້ [esbuild](https://esbuild.github.io/). esbuild ທີ່ຂຽນໃນພາສາ Go ແລະ ເປັນ pre-bundles dependencies  ທີ່ໄວກວ່າແບບ  JavaScript-based bundlers 10-100ເທົ່າ.

- **Source code** ມັກຈະມີ non-plain JavaScript ທີ່ຕ້ອງການການປ່ຽນແປງ (ເຊັ່ນ: JSX, CSS ຫຼື Vue/Svelte components), ແລະ ຈະຖືກແກ້ໄຂຢູ່ເລື້ອຍໆ. ນອກຈາກນີ້, ບໍ່ແມ່ນທັງໝົດຂອງ source code ທີ່ຕ້ອງຖືກໂຫຼດໃນເວລາດຽວກັນ (ເຊັ່ນ: ກັບ route-based code-splitting).

  Vite ແລ່ນ source code ຜ່ານ [native ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). ນີ້ແມ່ນສິ່ງຈຳເປັນທີ່ເຮັດໃຫ້ບາວເຊີເຂົ້າມາເປັນສ່ວນໜຶ່ງຂອງວຽກ ຂອງ bundler: Vite ພຽງແຕ່ຕ້ອງການປ່ຽນ ແລະ ແລ່ນ source code ຕາມຄວາມຕ້ອງການ, ຕອນທີ່ບາວເຊີຕ້ອງການມັນ. Code ທີ່ຢູ່ເບື້ອງຫຼັງຂອງເງື່ອນໄຂ import ແບບ dynamic ແມ່ນສະເພາະຕອນ process ເທົ່ານັ້ນ ຖ້າວ່າກຳລັງຖືກໃຊ້ງານໃນໜ້າຈໍປັດຈຸບັນ.

<script setup>
import bundlerSvg from '../images/bundler.svg?raw'
import esmSvg from '../images/esm.svg?raw'
</script>
<svg-image :svg="bundlerSvg" />
<svg-image :svg="esmSvg" />

### ອັບເດດຊ້າ

ເມື່ອຟາຍໃດໜຶ່ງຖືກແກ້ໄຂໃນ ການຕັ້ງຄ່າ build ແບບ bundler-based, ມັນບໍ່ມີປະສິດທິພາບທີ່ຈະ rebuild bundle ທັງໝົດ ເຫດຜົນແມ່ນ: ຄວາມໄວຂອງການອັບເດດຈະຫຼຸດລົງເກືອບເທົ່າກັນກັບຂະໜາດຂອງແອັບ.

ໃນບາງ bundlers, dev server ແລ່ນ bundling ໃນ memory ໂດຍມັນພຽງແຕ່ຕ້ອງການ invalidate module graph ບາງສ່ວນຂອງມັນ ເມືອຟາຍມີການປ່ຽນແປງ, ແຕ່ກໍຍັງຕ້ອງໄດ້ສ້າງ bundle ໃໝ່ທັງໝົດ ແລະ ໂຫຼດໜ້າເວັບຄືນໃໝ່. ການສ້າງ bundle ໃໝ່ອາດມີລາຄາແພງ ແລະ ການໂຫຼດໜ້າເວັບໃໝ່ອາດຈະເຮັດໃຫ້ສະຖານະປັດຈຸບັນຂອງແອັບພິເຄຊັ່ນເສຍໄປ. ນີ້ແມ່ນສາເຫດທີບາງ bundle ຮອງຮັບ Hot Module Replacement (HMR): ອະນຸຍາດໃຫ້ module "ແທນທີຢ່າງວ່ອງໄວ" ເອງ ໂດຍບໍ່ສົ່ງຜົນກະທົບຕໍ່ສ່ວນທີ່ເຫຼືອຂອງໜ້າເວັບ. ສິ່ງນີ້ຊ່ອຍປັບປຸງປະສົບການການພັດທະນາຂອງນັກພັດທະນາເປັນຢ່າງຫຼາຍ - ເຖິງຢ່າງໃດກໍຕາມ, ໃນທາງປະຕິບັດ ພວກເຮົາພົບວ່າຄວາມໄວໃນການອັບເດດຂອງ HMR ຈະຫຼຸດລົງຢ່າງຫຼາຍຕາມຂະໜາດຂອງແອັບພິເຄຊັ່ນທີ່ໃຫຍ່ຂຶ້ນ.

ໃນ Vite, HMR ເຮັດວຽກຜ່ານ native ESM. ເມືອຟາຍມີການແກ້ໄຂ, Vite ຈຳເປັນຕ້ອງເຮັດໃຫ້ຫ່ວງໂຊ່ລະຫວ່າງໂມດູທີ່ແກ້ໄຂ ແລະ ຂອບເຂດຂອງ HMR ເອງ ທີ່ໃກ້ທີ່ສຸດ invalidate ແລະ ຖືກຕ້ອງທີ່ສຸດ (ໂດຍສ່ວນໃຫຍ່ແລ້ວແມ່ນສະເພາະ module ເທົ່ານັ້ນ), ເຮັດໃຫ້ການອັບເດດ HMR ວ່ອງໄວຢ່າງສະໝໍ່າສະເໝີໂດຍບໍ່ສົນຂະໜາດຂອງແອັບພິເຄຊັ່ນຂອງທ່ານ.

Vite ຍັງໃຊ້ HTTP headers ເພື່ອເລັ່ງຄວາມໄວຂອງການໂຫຼດໜ້າເວັບທັງໝົດຄືນໃໝ່ (ອີກເທື່ອໜຶ່ງ, ໃຫ້ບາວເຊີເຮັດວຽກໃຫ້ເຮົາຫຼາຍຂຶ້ນ): source code module ຕ້ອງການປ່ຽນແປງເງື່ອນໄຂຜ່ານ `304 Not Modified`, ແລະ dependency module ຕ້ອງການ cache ຢ່າງຫຼາຍຜ່ານ `Cache-Control: max-age=31536000,immutable` ດັ່ງນັ້ນພວກເຂົາຈິງບໍ່ຕ້ອງແລ່ນ server ໃໝ່ອີກຄັ້ງຖ້າມັນຖືກ cache ແລ້ວ.

ເມື່ອທ່ານໄດ້ສຳພັດກັບຄວາມໄວຂອງ Vite ແລ້ວ, ພວກເຮົາມິຄວາມສົງໄສເປັນຢ່າງສູງວ່າ ທ່ານຈະເຕັມໃຈທີ່ຈະເຮັດໃຫ້ມີການພັດທະນາ bundle ອີກຄັ້ງ.

## ເປັນຫຍັງຕ້ອງ Bundle ສຳລັບ Production

ເຖິງແມ່ນວ່າ native ESM ໄດ້ຮັບການສະໜັບສະໜູນຢ່າງກວ້າງຂວາງໃນປັດຈຸບັນ, shipping unbundled ESM ໃນ production ແມ່ນຍັງບໍ່ມີປະສິດທິພາບ (ເຖິງແມ່ນວ່າມີ HTTP/2) ເນື່ອງຈາກການເດີນທາງຮອບເຄືອຂ່າຍເພີ່ມເຕີມທີເກີດຈາກ nested import. ເພື່ອໃຫ້ໄດ້ປະສິດທິພາບການໂຫຼດທີ່ດີທີ່ສຸດໃນ production, ມັນດີກວ່າທີ່ຈະ bundle code ຂອງທ່ານກັບ tree-shaking, lazy-loading ແລະ common chunk splitting (ສຳລັບການ cache ທີ່ດີກວ່າ).

ການຮັບປະກັນຜົນລັບທີ່ດີທີ່ສຸດ ແລະ ຄວາມສອດຄ່ອງທາງດ້ານພຶດຕິກຳລະຫວ່າງ dev server ແລະ production build ບໍ່ແມ່ນເລື່ອງງ່າຍ. ນີ້ແມ່ນເຫດຜົນເປັນຫຍັງ Vite ຈິງ ship ກັບ pre-configured [build command](./build) ທີ່ນຳ [ການເພີ່ມປະສິດທິພາບ](./features#build-optimizations) ມາໃຊ້ຢ່າງຫຼວງຫຼາຍຕັ້ງແຕ່ເລີ່ມຕົ້ນ.

## ເປັນຫຍັງບໍ່ Bundle ກັບ esbuild?

API plugin ປັດຈຸບັນຂອງ Vite ບໍ່ຮອງຮັບການໃຊ້ `esbuild` ເປັນ bundler. ເຖິງວ່າ `esbuild` ຈະໄວກວ່າ ການຮັບຮອງເອົາ Vite ຂອງ Rollup's flexible plugin API ແລະ intrastructure ໄດ້ປະກອບສ່ວນຢ່າງໃຫຍ່ຫຼວງກັບຄວາມສຳເລັດຂອງມັນໃນລະບົບນິເວດ. ສຳລັບເວລານີ້, ພວກເຮົາເຊື່ອວ່າ Rollup ໃຫ້ການແລກປ່ຽນລະຫວ່າງປະສິດທິພາບກັບຄວາມຍືດຍຸ່ນທີ່ດີກວ່າ.

ທີ່ເວົ້າວ່າ, `esbuild` ມີຄວາມກ້າວໜ້າຫຼາຍໃນປີທີ່ຜ່ານມາ, ແລະ ພວກເຮົາຈະບໍ່ປະຕິເສດຄວາມເປັນໄປໄດ້ຂອງການນຳໃຊ້ `esbuild` ສຳລັບ production build ໃນອະນາຄົດ. ພວກເຮົາຈະສືບຕໍ່ໃຊ້ປະໂຫຍດຈາກຄວາມສາມາດໃໝ່ຍ້ອນວ່າພວກມັນຖືກປ່ອຍອອກມາ, ດັ່ງທີ່ພວກເຮົາໄດ້ເຮັດກັບ JS ແລະ CSS minification ບ່ອນທີ່ `esbuild` ອະນຸຍາດໃຫ້ Vite ໄດ້ຮັບການເພີ່ມປະສິດທິພາບໃນຂະນະທີ່ຫຼີກເວັ້ນການຂັດຂວາງລະບົບນິເວດຂອງມັນ.

## ແລ້ວ Vite ມັນແຕກຕ່າງຈາກ X ແນວໃດ?

ທ່ານສາມາດເບິ່ງ ຫົວຂໍ້ [ການປຽບທຽບ](./comparisons) ສຳລັບລາຍລະອຽດເພີ່ມເຕີມວ່າ Vite ຕ່າງຈາກເຄື່ອງມືທີໃກ້ຄຽງແນວໃດ.
